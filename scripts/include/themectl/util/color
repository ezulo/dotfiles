#!/usr/bin/env bash

ID_COLOR="$_ID:util:color"

# This themectl utility pulls color values out of the current theme's 
# `scheme.json` and prints them (prettily)

# Luminance Delta Threshold (0 through 255) (default: 70)
# When the background and color are too similar, we color the output background 
# instead of the foreground. Decrease this to make this effect more sensitive.
L_DELTA_THRESHOLD=70

# Space between pretty print inline members
PRETTY_PRINT_PADDING=5

[ -z $THEME ] &&
    log_error $ID_COLOR "No theme detected. Set THEME before sourcing." && exit 1
[ ! -f $COLORS_JSON ] &&
    log_error $ID_COLOR "Required file $COLORS_JSON missing." && exit 1

NO_COLOR=
[ ! command -v bc > /dev/null 2>&1 ] &&
    log_warn $ID_COLOR "bc not found. Color output disabled." && NO_COLOR=1

# Helper function to calculate perceived luminance, used for colorizing output
rgb_luminance() {
    local EQ="0.2126 * $1 + 0.7152 * $2 + 0.0722 * $3"
    local L=$(echo "$EQ" | bc);
    printf "%.0f" "$L"
}

# Colorizes color hex (#000000 to #ffffff)
colorize_hex() {
    local HEX=$1 #e.g. "#012345"
    local HEX_REGEX="^#[0-9|a-f]+$"
    [[ ! $HEX =~ $HEX_REGEX ]] || [ $(echo "$HEX" | wc -L) -ne 7 ] &&
        echo -ne "${HEX}[INVALID]" && return 1
    local R=$((16#"${HEX:1:2}"))
    local G=$((16#"${HEX:3:2}"))
    local B=$((16#"${HEX:5:2}"))
    local L=$(rgb_luminance $R $G $B)
    local BG_L=$(bg_luminance)
    local L_DELTA=$(echo "$BG_L - $L" | bc)
    local COL_FG="\\033[38;2"
    local COL_BG="\\033[48;2"
    local COL_SEQ="${COL_FG};${R};${G};${B}m"
    local COL_CLEAR='\033[0m'
    [ ${L_DELTA#-} -lt $L_DELTA_THRESHOLD ] &&
        COL_SEQ="${COL_BG};${R};${G};${B}m"
    echo -n "${COL_SEQ}${HEX}${COL_CLEAR}"
}

# Gets hex code from colors.json based on query
get_color_hex() {
    local ID="$ID:$ID_COLOR:$FUNCNAME"
    local QUERY=$1
    case $QUERY in
        color*)
            local COLOR_CODE=$(echo "${QUERY#*color}")
            [ $COLOR_CODE -gt 15 ] || [ $COLOR_CODE -lt 0 ] &&
                log_error $ID "Color code $COLOR_CODE out of range (0-15)" &&
                return 1
            COLOR=$(jq -r .[\"colors\"].$QUERY $COLORS_JSON)
            ;;
        *)
            COLOR=$(jq -r .[\"special\"].$QUERY $COLORS_JSON)
            [ "$COLOR" = "null" ] &&
                log_error $ID "Color not found: $COLOR" && return 1
            ;;
    esac
    printf "%b" "$COLOR"
}

# Prints colorized output (or non-colorized, if NO_COLOR is set)
print_color() {
    QUERY=$1
    KEY=$2
    NO_COLOR=$3
    NEWLINE=$4
    [ -z "$KEY" ] && KEY="$QUERY"
    COLOR_HEX=$(get_color_hex $1)
    [ -z $NO_COLOR ] && COLOR_HEX=$(colorize_hex "$COLOR_HEX")
    OUT=$(echo -n "${KEY}: ")"${COLOR_HEX}"
    [ ! -z $NEWLINE ] && OUT="$OUT\n"
    printf "%b" "$OUT"
}

# Calculates background luminance (uses color0 if background undefined)
bg_luminance() {
    BG_HEX=$(get_color_hex background || get_color_hex color0)
    BG_R=$((16#${BG_HEX:1:2}))
    BG_G=$((16#${BG_HEX:3:2}))
    BG_B=$((16#${BG_HEX:5:2}))
    printf "%b" "$(rgb_luminance $BG_R $BG_G $BG_B)"
}

string_width() {
    echo "$1" |  sed 's/\x1B\[[0-9;]*[a-zA-Z]//g' | wc -L
}

colors_max_width() {
    local COLORS=("$@")
    COLORS_MW=0
    for COLOR in "${COLORS[@]}"; do
        WIDTH=$(string_width "$COLOR")
        [ $WIDTH -gt $COLORS_MW ] && COLORS_MW=$WIDTH
    done
    echo $COLORS_MW
}

pretty_print_align_hex() {
    local COLOR=$1
    local COLOR_MW=$2
    WIDTH=$(string_width "$COLOR")
    DELTA=$((COLOR_MW - WIDTH))
    local IFS=' '
    [[ $DELTA -gt 0 ]] &&
        read -ra COLOR_P <<< "$COLOR" &&
        printf "%b%*s%b" "${COLOR_P[0]}" "$((DELTA + 1))" "${COLOR_P[1]}" \
        ||
        printf "%b" "${COLOR}"
}

pretty_print_all() {
    local COLOR_COLUMNS="$1"
    shift
    local COLORS=("$@")
    # Get max width
    COLORS_MW=$(colors_max_width "${COLORS[@]}")
    MAX_I=$((${#COLORS[@]} / $COLOR_COLUMNS))
    for i in $(eval echo {0..$((MAX_I - 1))}); do
        for j in $(eval echo {0..$(($COLOR_COLUMNS - 1))}); do
            IDX=$((i + j * MAX_I))
            COLOR="${COLORS[$IDX]}"
            WIDTH=$(string_width "$COLOR")
            SPACES=$(($((COLORS_MW - WIDTH)) + PRETTY_PRINT_PADDING))
            pretty_print_align_hex "$COLOR" "$COLORS_MW"
            printf '%*s' "$SPACES" ''
        done
        echo ""
    done
}

themecolor() {
    QUERY=$1
    [[ "$QUERY" =~ ^[0-9]+$ ]] && QUERY="color${QUERY}"
    [ -z $NO_COLOR ] && NO_COLOR=$2
    case "$QUERY" in
        "all")
            COLORS=()
            COLORS_SPECIAL=()
            for i in {0..15}; do
                QUERY="color${i}"
                COLOR_OUT=$(print_color "$QUERY" "$QUERY" "$NO_COLOR" "")
                COLORS+=("$COLOR_OUT")
            done
            SPEC_KEYS=$(jq -r '.special | keys[]' "$COLORS_JSON")
            while IFS="\r" read QUERY; do
                COLOR_OUT=$(print_color "$QUERY" "$QUERY" "$NO_COLOR" "")
                COLORS_SPECIAL+=("$COLOR_OUT")
            done <<< $SPEC_KEYS
            pretty_print_all 2 "${COLORS[@]}"
            pretty_print_all 1 "${COLORS_SPECIAL[@]}"
            ;;
        *)
            print_color "$QUERY" "" "$NO_COLOR" "1"
            ;;
    esac
}


