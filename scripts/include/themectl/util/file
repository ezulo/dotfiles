#!/usr/bin/env bash

ID_FILE="$_ID:file"

# This themectl utility handles common file I/O ops for theming

clear_files() {
    local ID="$ID_FILE:$FUNCNAME"
    for file in "$@"; do
        rm -f "$file" && log_trace "$ID" "Deleted file: $file"
    done
}

clear_dir() {
    local ID="$ID_FILE:$FUNCNAME"
    DIR=$1
    [ -d "$DIR" ] && rm -rf "$DIR"/* && log_trace "$ID" "Cleaned dir: $DIR"
}

# Destination directory assumed to be created already
commit_dir() {
    local ID="$ID_FILE:$FUNCNAME"
    SRC=$1
    DST=$2
    log_trace "$ID" "invoked: commit_dir $SRC $DST"
    [ ! -d "$SRC" ] && 
        log_trace "$ID" "Source directory [ $SRC ] not found" && return 1 
    [ ! -d $"$DST" ] &&
        log_trace "$ID" "$SRC -> $DST; destination not found" && return 1
    for file in ${SRC}/*; do
        commit_file "${file}" "${DST}/$(basename $file)"
    done
}

commit_file() {
    local ID="$ID_FILE:$FUNCNAME"
    SRC=$1
    DST=$2
    # RECURSION WARNING
    [ -d "$SRC" ] && commit_dir "$SRC" "$DST" && return
    cp "$SRC" "$DST" &&
        log_trace "$ID" "Committed $SRC to $DST" ||
        log_trace "$ID" "Could not commit $SRC to $DST: error code $?"
}

# Generates a human readable timestamp
timestamp_now() {
    local ID="$ID_FILE:$FUNCNAME"
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    [ ! -z "$TIMESTAMP" ] &&
        log_trace "$ID" "Timestamp created: $TIMESTAMP"
    printf "%b" "$TIMESTAMP"
}

# Function for generating (multiline comment) file headers to a file.
# Will overwrite a file. Run this first and then append additional data.
# If IN_FILE is a directory, will list all the files therein
write_file_header() {
    local ID="$ID_FILE:$FUNCNAME"
    local OUT_FILE="$1" && shift
    local IN_FILE="$1" && shift
    local MODE="${1:-bash}" && shift
    local EXTRA_LINES=("$@")
    log_trace $ID "Writing file header: $OUT_FILE in mode: $MODE"
    COMMENT_BEGIN=
    COMMENT_LINE=
    COMMENT_END=
    [ ! -z "$MODE" ] && case "$MODE" in
        c | css)
            log_trace "$ID" "Using C/CSS style comments"
            local COMMENT_BEGIN="/*"
            local COMMENT_LINE=" * "
            local COMMENT_END=" */"
            ;;
        dunst)
            log_trace "$ID" "Using dunstrc style comments"
            local COMMENT_BEGIN="; "
            local COMMENT_LINE="; "
            local COMMENT_END="; "
            ;;
        nocomment)
            log_trace "$ID" "Using no comment prefix"
            ;;
        bash | conf | *)
            ! [[ "$MODE" =~ ^(bash|conf) ]] &&
                log_warn $ID "Unrecognized mode: $MODE. Defaulting to bash."
            log_trace "$ID" "Using shell script comments"
            local COMMENT_BEGIN="# "
            local COMMENT_LINE="# "
            local COMMENT_END="# "
            ;;
    esac
    local CONTENT="\
        $(basename "$OUT_FILE") was autogenerated by $_ID\n\
        theme: $THEME\n\
        timestamp: $(timestamp_now) \n\
        \n\
        DO NOT EDIT THIS FILE! It will be overwritten."
    local IN_FILES=()
    [ ! -z "$IN_FILE" ] && (
        [ -d "$IN_FILE" ] &&
        readarray -t IN_FILES <<< $(ls -1 --color=none "$IN_FILE")
    ) || IN_FILES=($IN_FILE) &&
        CONTENT="$CONTENT\n\
            For persistent changes, edit the source file(s) located here:" &&
        for F in "${IN_FILES[@]}"; do
            CONTENT="$CONTENT\n- \`$F\`"
        done
        CONTENT="$CONTENT\n\n\
            ...and perform a \`$_ID reload\` to generate a new file."
    [ ${#EXTRA_LINES[@]} -gt 0 ] &&
        for $LINE in ${EXTRA_LINES[@]}; do CONTENT="$CONTENT\n$LINE"; done
    CONTENT=$(echo -e "$CONTENT" | sed "s/^ */$COMMENT_LINE/")
    echo -e "$COMMENT_BEGIN\n$CONTENT\n$COMMENT_END\n" > "$OUT_FILE" &&
        log_trace "$ID" "File header written: $OUT_FILE"
}

